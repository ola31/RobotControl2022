/*
 * RoK-3 Gazebo Simulation Code 
 * 
 * Robotics & Control Lab.
 * 
 * Master : BKCho
 * First developer : Yunho Han
 * Second developer : Minho Park
 * 
 * ======
 * Update date : 2022.03.16 by Yunho Han
 * ======
 */
//* Header file for C++
#include <stdio.h>
#include <iostream>
#include <boost/bind.hpp>

//* Header file for Gazebo and Ros
#include <gazebo/gazebo.hh>
#include <ros/ros.h>
#include <gazebo/common/common.hh>
#include <gazebo/common/Plugin.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/sensors/sensors.hh>
#include <std_msgs/Float32MultiArray.h>
#include <std_msgs/Int32.h>
#include <std_msgs/Float64.h>
#include <functional>
#include <ignition/math/Vector3.hh>

//* Header file for RBDL and Eigen
#include <rbdl/rbdl.h> // Rigid Body Dynamics Library (RBDL)
#include <rbdl/addons/urdfreader/urdfreader.h> // urdf model read using RBDL
#include <Eigen/Dense> // Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.

#define PI      3.141592
#define D2R     PI/180.
#define R2D     180./PI

//Print color
#define C_BLACK   "\033[30m"
#define C_RED     "\x1b[91m"
#define C_GREEN   "\x1b[92m"
#define C_YELLOW  "\x1b[93m"
#define C_BLUE    "\x1b[94m"
#define C_MAGENTA "\x1b[95m"
#define C_CYAN    "\x1b[96m"
#define C_RESET   "\x1b[0m"

//Eigen//
using Eigen::MatrixXd;
using Eigen::VectorXd;

//RBDL//
using namespace RigidBodyDynamics;
using namespace RigidBodyDynamics::Math;

using namespace std;

VectorXd q_init(6), q_init_R(6), q_cal(6), q_cal_R(6), q(6), q_R(6), q_prev(6), q_prev_R(6);
Vector3d r_init, r_init_R;

double T=5;
double r_x, r_y, r_z, r_x_R, r_y_R, r_z_R;
Vector3d r, r2, r_R, r_des, r_des_R, r_des_prev, r_des_R_prev;
MatrixXd C_init(3,3), C_des2(3,3), C_tmp(3,3), C_err(3,3);
// MatrixXd C_des = MatrixXd::Identity(3,3); // 발바닥 자체는 회전하지 않으므로
MatrixXd C_des(3,3);

double phi_x, phi_y, phi_z;
VectorXd des_phi(3), phi(3);
int flag = 0;
namespace gazebo
{

    class rok3_plugin : public ModelPlugin
    {
        //*** Variables for RoK-3 Simulation in Gazebo ***//
        //* TIME variable
        common::Time last_update_time;
        event::ConnectionPtr update_connection;
        double dt;
        double time = 0;

        //* Model & Link & Joint Typedefs
        physics::ModelPtr model;

        physics::JointPtr L_Hip_yaw_joint;
        physics::JointPtr L_Hip_roll_joint;
        physics::JointPtr L_Hip_pitch_joint;
        physics::JointPtr L_Knee_joint;
        physics::JointPtr L_Ankle_pitch_joint;
        physics::JointPtr L_Ankle_roll_joint;

        physics::JointPtr R_Hip_yaw_joint;
        physics::JointPtr R_Hip_roll_joint;
        physics::JointPtr R_Hip_pitch_joint;
        physics::JointPtr R_Knee_joint;
        physics::JointPtr R_Ankle_pitch_joint;
        physics::JointPtr R_Ankle_roll_joint;
        physics::JointPtr torso_joint;

        physics::JointPtr LS, RS;

        //* Index setting for each joint
        
        enum
        {
            WST = 0, LHY, LHR, LHP, LKN, LAP, LAR, RHY, RHR, RHP, RKN, RAP, RAR
        };

        //* Joint Variables
        int nDoF; // Total degrees of freedom, except position and orientation of the robot

        typedef struct RobotJoint //Joint variable struct for joint control 
        {
            double targetDegree; //The target deg, [deg]
            double targetRadian; //The target rad, [rad]

            double targetVelocity; //The target vel, [rad/s]
            double targetTorque; //The target torque, [N·m]

            double actualDegree; //The actual deg, [deg]
            double actualRadian; //The actual rad, [rad]
            double actualVelocity; //The actual vel, [rad/s]
            double actualRPM; //The actual rpm of input stage, [rpm]
            double actualTorque; //The actual torque, [N·m]

            double Kp;
            double Ki;
            double Kd;

        } ROBO_JOINT;
        ROBO_JOINT* joint;

    public:
        //*** Functions for RoK-3 Simulation in Gazebo ***//
        void Load(physics::ModelPtr _model, sdf::ElementPtr /*_sdf*/); // Loading model data and initializing the system before simulation 
        void UpdateAlgorithm(); // Algorithm update while simulation

        void jointController(); // Joint Controller for each joint

        void GetJoints(); // Get each joint data from [physics::ModelPtr _model]
        void GetjointData(); // Get encoder data of each joint

        void initializeJoint(); // Initialize joint variables for joint control
        void SetJointPIDgain(); // Set each joint PID gain for joint control
    };
    GZ_REGISTER_MODEL_PLUGIN(rok3_plugin);
}



MatrixXd getTransformI0(){
    MatrixXd tmp_m = MatrixXd::Identity(4,4); //단위행렬

    return tmp_m;
}

MatrixXd getTransform6E(){
    MatrixXd tmp_m(4,4);

    double z = -0.09;

    tmp_m <<1, 0, 0, 0, \
            0, 1, 0, 0, \
            0, 0, 1, z, \
            0, 0, 0, 1;
    
    return tmp_m;
}

MatrixXd jointToTransform01(VectorXd q){
    double qq = q(0);
    double sq = sin(qq);
    double cq = cos(qq);

    MatrixXd tmp_m(4,4);
    tmp_m <<cq, -sq, 0, 0, \
            sq, cq, 0, 0.105, \
            0, 0, 1, -0.1512, \
            0, 0, 0, 1;

    return tmp_m;
}

MatrixXd jointToTransform01_R(VectorXd q){
    double qq = q(0);
    double sq = sin(qq);
    double cq = cos(qq);

    MatrixXd tmp_m(4,4);
    tmp_m <<cq, -sq, 0, 0, \
            sq, cq, 0, -0.105, \
            0, 0, 1, -0.1512, \
            0, 0, 0, 1;

    return tmp_m;
}

MatrixXd jointToTransform12(VectorXd q){
    double qq = q(1);
    double sq = sin(qq);
    double cq = cos(qq);

    MatrixXd tmp_m(4,4);
    tmp_m <<1, 0, -0, 0, \
            0, cq, -sq, 0, \
            0, sq, cq, 0, \
            0, 0, 0, 1;

    return tmp_m;
}

MatrixXd jointToTransform23(VectorXd q){
    double qq = q(2);
    double sq = sin(qq);
    double cq = cos(qq);

    MatrixXd tmp_m(4,4);
    tmp_m <<cq, 0, sq, 0, \
            0, 1, 0, 0, \
            -sq, 0, cq, 0, \
            0, 0, 0, 1;

    return tmp_m;
}

MatrixXd jointToTransform34(VectorXd q){
    double qq = q(3);
    double sq = sin(qq);
    double cq = cos(qq);

    MatrixXd tmp_m(4,4);
    tmp_m <<cq, 0, sq, 0, \
            0, 1, 0, 0, \
            -sq, 0, cq, -0.35, \
            0, 0, 0, 1;

    return tmp_m;
}

MatrixXd jointToTransform45(VectorXd q){
    double qq = q(4);
    double sq = sin(qq);
    double cq = cos(qq);

    MatrixXd tmp_m(4,4);
    tmp_m <<cq, 0, sq, 0, \
            0, 1, 0, 0, \
            -sq, 0, cq, -0.35, \
            0, 0, 0, 1;

    return tmp_m;
}

MatrixXd jointToTransform56(VectorXd q){
    double qq = q(5);
    double sq = sin(qq);
    double cq = cos(qq);

    MatrixXd tmp_m(4,4);
    tmp_m <<1, 0, 0, 0, \
            0, cq, -sq, 0, \
            0, sq, cq, 0, \
            0, 0, 0, 1;

    return tmp_m;
}

VectorXd jointToPosition(VectorXd q){ //동차변환행렬에서 위치벡터찾기
    MatrixXd TI0(4,4),T6E(4,4),T01(4,4),T12(4,4),T23(4,4), T34(4,4), T45(4,4), T56(4,4);
    MatrixXd TIE(4,4);

    TI0 = getTransformI0();
    T01 = jointToTransform01(q);
    T12 = jointToTransform12(q);
    T23 = jointToTransform23(q);
    T34 = jointToTransform34(q);
    T45 = jointToTransform45(q);
    T56 = jointToTransform56(q);
    T6E = getTransform6E();

    TIE = TI0 * T01 * T12 * T23 * T34 * T45 * T56 * T6E;
    
    Vector3d position;

    position = TIE.block(0,3,3,1);
    
    return position;
}

VectorXd jointToPosition_R(VectorXd q){ //동차변환행렬에서 위치벡터찾기
    MatrixXd TI0(4,4),T6E(4,4),T01(4,4),T12(4,4),T23(4,4), T34(4,4), T45(4,4), T56(4,4);
    MatrixXd TIE(4,4);

    TI0 = getTransformI0();
    T01 = jointToTransform01_R(q);
    T12 = jointToTransform12(q);
    T23 = jointToTransform23(q);
    T34 = jointToTransform34(q);
    T45 = jointToTransform45(q);
    T56 = jointToTransform56(q);
    T6E = getTransform6E();

    TIE = TI0 * T01 * T12 * T23 * T34 * T45 * T56 * T6E;
    
    Vector3d position;

    position = TIE.block(0,3,3,1);
    
    return position;
}


MatrixXd jointToRotMat(VectorXd q){ //동차변환행렬에서 회전행렬찾기
    MatrixXd TI0(4,4),T6E(4,4),T01(4,4),T12(4,4),T23(4,4), T34(4,4), T45(4,4), T56(4,4);
    MatrixXd TIE(4,4);

    TI0 = getTransformI0();
    T01 = jointToTransform01(q);
    T12 = jointToTransform12(q);
    T23 = jointToTransform23(q);
    T34 = jointToTransform34(q);
    T45 = jointToTransform45(q);
    T56 = jointToTransform56(q);
    T6E = getTransform6E();

    TIE = TI0 * T01 * T12 * T23 * T34 * T45 * T56 * T6E;

    MatrixXd rot_m(3,3);

    rot_m = TIE.block(0, 0, 3, 3);
    return rot_m;
}

MatrixXd jointToRotMat_R(VectorXd q){ //동차변환행렬에서 회전행렬찾기
    MatrixXd TI0(4,4),T6E(4,4),T01(4,4),T12(4,4),T23(4,4), T34(4,4), T45(4,4), T56(4,4);
    MatrixXd TIE(4,4);

    TI0 = getTransformI0();
    T01 = jointToTransform01_R(q);
    T12 = jointToTransform12(q);
    T23 = jointToTransform23(q);
    T34 = jointToTransform34(q);
    T45 = jointToTransform45(q);
    T56 = jointToTransform56(q);
    T6E = getTransform6E();

    TIE = TI0 * T01 * T12 * T23 * T34 * T45 * T56 * T6E;

    MatrixXd rot_m(3,3);

    rot_m = TIE.block(0, 0, 3, 3);
    return rot_m;
}

VectorXd rotToEuler(MatrixXd rot_mat){ // 회전행렬을 Euler ZYX로
    VectorXd euler_zyx = VectorXd::Zero(3);

    euler_zyx(0) = atan2( rot_mat(1,0) , rot_mat(0,0) );
    euler_zyx(1) = atan2( -rot_mat(2,0) , sqrt( pow(rot_mat(2,1),2) + pow(rot_mat(2,2),2) ));
    euler_zyx(2) = atan2( rot_mat(2,1), rot_mat(2,2));

    euler_zyx *= R2D;
    return euler_zyx;
}

MatrixXd jointToPosJac(VectorXd q) // generalized coordinate로 position 쟈코비안 구하기
{
    // Input: vector of generalized coordinates (joint angles)
    // Output: J_P, Jacobian of the end-effector translation which maps joint velocities to end-effector linear velocities in I frame.
    MatrixXd J_P = MatrixXd::Zero(3,6);
    MatrixXd T_I0(4,4), T_01(4,4), T_12(4,4), T_23(4,4), T_34(4,4), T_45(4,4), T_56(4,4), T_6E(4,4);
    MatrixXd T_I1(4,4), T_I2(4,4), T_I3(4,4), T_I4(4,4), T_I5(4,4), T_I6(4,4);
    MatrixXd R_I1(3,3), R_I2(3,3), R_I3(3,3), R_I4(3,3), R_I5(3,3), R_I6(3,3);
    Vector3d r_I_I1, r_I_I2, r_I_I3, r_I_I4, r_I_I5, r_I_I6;
    Vector3d n_1, n_2, n_3, n_4, n_5, n_6;
    Vector3d n_I_1,n_I_2,n_I_3,n_I_4,n_I_5,n_I_6;
    Vector3d r_I_IE;


    //* Compute the relative homogeneous transformation matrices. 동차변환 행렬 구하기. practice 2 에서 만든 함수 활용.
    T_I0 = getTransformI0();
    T_01 = jointToTransform01(q);
    T_12 = jointToTransform12(q);
    T_23 = jointToTransform23(q);
    T_34 = jointToTransform34(q);
    T_45 = jointToTransform45(q);
    T_56 = jointToTransform56(q);
    T_6E = getTransform6E();

    //* Compute the homogeneous transformation matrices from frame k to the inertial frame I. I좌표계에 대해
    T_I1 = T_I0 * T_01;
    T_I2 = T_I0 * T_01 * T_12;
    T_I3 = T_I0 * T_01 * T_12 * T_23;
    T_I4 = T_I0 * T_01 * T_12 * T_23 * T_34;
    T_I5 = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45;
    T_I6 = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45 * T_56;

    //* Extract the rotation matrices from each homogeneous transformation matrix. Use sub-matrix of EIGEN. https://eigen.tuxfamily.org/dox/group__QuickRefPage.html
    R_I1 = T_I1.block(0,0,3,3);
    R_I2 = T_I2.block(0,0,3,3);
    R_I3 = T_I3.block(0,0,3,3);
    R_I4 = T_I4.block(0,0,3,3);
    R_I5 = T_I5.block(0,0,3,3);
    R_I6 = T_I6.block(0,0,3,3);

    //* Extract the position vectors from each homogeneous transformation matrix. Use sub-matrix of EIGEN.
    r_I_I1 = T_I1.block(0,3,3,1);
    r_I_I2 = T_I2.block(0,3,3,1);
    r_I_I3 = T_I3.block(0,3,3,1);
    r_I_I4 = T_I4.block(0,3,3,1);
    r_I_I5 = T_I5.block(0,3,3,1);
    r_I_I6 = T_I6.block(0,3,3,1);

    //* Define the unit vectors around which each link rotate in the precedent coordinate frame.  
    n_1 << 0,0,1; //1번 좌표계에서 본 1번 좌표계의 회전축의 단위벡터
    n_2 << 1,0,0;
    n_3 << 0,1,0;
    n_4 << 0,1,0;
    n_5 << 0,1,0;
    n_6 << 1,0,0;

    //* Compute the unit vectors for the inertial frame I.
    n_I_1 = R_I1*n_1; // inertial frame(절대 좌표계) 에서 본 1번 좌표계의 회전축의 단위벡터
    n_I_2 = R_I2*n_2;
    n_I_3 = R_I3*n_3;
    n_I_4 = R_I4*n_4;
    n_I_5 = R_I5*n_5;
    n_I_6 = R_I6*n_6;

    //* Compute the end-effector position vector.
    MatrixXd T_IE(4,4);
    T_IE = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45 * T_56 * T_6E;
    r_I_IE = T_IE.block(0,3,3,1);

    //* Compute the translational Jacobian. Use cross of EIGEN.
    J_P.col(0) << n_I_1.cross(r_I_IE - r_I_I1);
    J_P.col(1) << n_I_2.cross(r_I_IE - r_I_I2);
    J_P.col(2) << n_I_3.cross(r_I_IE - r_I_I3);
    J_P.col(3) << n_I_4.cross(r_I_IE - r_I_I4);
    J_P.col(4) << n_I_5.cross(r_I_IE - r_I_I5);
    J_P.col(5) << n_I_6.cross(r_I_IE - r_I_I6);

    // std::cout << "Test, J_P:" << std::endl << J_P << std::endl;

    return J_P;
}

MatrixXd jointToPosJac_R(VectorXd q) // generalized coordinate로 position 쟈코비안 구하기
{
    // Input: vector of generalized coordinates (joint angles)
    // Output: J_P, Jacobian of the end-effector translation which maps joint velocities to end-effector linear velocities in I frame.
    MatrixXd J_P = MatrixXd::Zero(3,6);
    MatrixXd T_I0(4,4), T_01(4,4), T_12(4,4), T_23(4,4), T_34(4,4), T_45(4,4), T_56(4,4), T_6E(4,4);
    MatrixXd T_I1(4,4), T_I2(4,4), T_I3(4,4), T_I4(4,4), T_I5(4,4), T_I6(4,4);
    MatrixXd R_I1(3,3), R_I2(3,3), R_I3(3,3), R_I4(3,3), R_I5(3,3), R_I6(3,3);
    Vector3d r_I_I1, r_I_I2, r_I_I3, r_I_I4, r_I_I5, r_I_I6;
    Vector3d n_1, n_2, n_3, n_4, n_5, n_6;
    Vector3d n_I_1,n_I_2,n_I_3,n_I_4,n_I_5,n_I_6;
    Vector3d r_I_IE;


    //* Compute the relative homogeneous transformation matrices. 동차변환 행렬 구하기. practice 2 에서 만든 함수 활용.
    T_I0 = getTransformI0();
    T_01 = jointToTransform01_R(q);
    T_12 = jointToTransform12(q);
    T_23 = jointToTransform23(q);
    T_34 = jointToTransform34(q);
    T_45 = jointToTransform45(q);
    T_56 = jointToTransform56(q);
    T_6E = getTransform6E();

    //* Compute the homogeneous transformation matrices from frame k to the inertial frame I. I좌표계에 대해
    T_I1 = T_I0 * T_01;
    T_I2 = T_I0 * T_01 * T_12;
    T_I3 = T_I0 * T_01 * T_12 * T_23;
    T_I4 = T_I0 * T_01 * T_12 * T_23 * T_34;
    T_I5 = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45;
    T_I6 = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45 * T_56;

    //* Extract the rotation matrices from each homogeneous transformation matrix. Use sub-matrix of EIGEN. https://eigen.tuxfamily.org/dox/group__QuickRefPage.html
    R_I1 = T_I1.block(0,0,3,3);
    R_I2 = T_I2.block(0,0,3,3);
    R_I3 = T_I3.block(0,0,3,3);
    R_I4 = T_I4.block(0,0,3,3);
    R_I5 = T_I5.block(0,0,3,3);
    R_I6 = T_I6.block(0,0,3,3);

    //* Extract the position vectors from each homogeneous transformation matrix. Use sub-matrix of EIGEN.
    r_I_I1 = T_I1.block(0,3,3,1);
    r_I_I2 = T_I2.block(0,3,3,1);
    r_I_I3 = T_I3.block(0,3,3,1);
    r_I_I4 = T_I4.block(0,3,3,1);
    r_I_I5 = T_I5.block(0,3,3,1);
    r_I_I6 = T_I6.block(0,3,3,1);

    //* Define the unit vectors around which each link rotate in the precedent coordinate frame.  
    n_1 << 0,0,1; //1번 좌표계에서 본 1번 좌표계의 회전축의 단위벡터
    n_2 << 1,0,0;
    n_3 << 0,1,0;
    n_4 << 0,1,0;
    n_5 << 0,1,0;
    n_6 << 1,0,0;

    //* Compute the unit vectors for the inertial frame I.
    n_I_1 = R_I1*n_1; // inertial frame(절대 좌표계) 에서 본 1번 좌표계의 회전축의 단위벡터
    n_I_2 = R_I2*n_2;
    n_I_3 = R_I3*n_3;
    n_I_4 = R_I4*n_4;
    n_I_5 = R_I5*n_5;
    n_I_6 = R_I6*n_6;

    //* Compute the end-effector position vector.
    MatrixXd T_IE(4,4);
    T_IE = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45 * T_56 * T_6E;
    r_I_IE = T_IE.block(0,3,3,1);

    //* Compute the translational Jacobian. Use cross of EIGEN.
    J_P.col(0) << n_I_1.cross(r_I_IE - r_I_I1);
    J_P.col(1) << n_I_2.cross(r_I_IE - r_I_I2);
    J_P.col(2) << n_I_3.cross(r_I_IE - r_I_I3);
    J_P.col(3) << n_I_4.cross(r_I_IE - r_I_I4);
    J_P.col(4) << n_I_5.cross(r_I_IE - r_I_I5);
    J_P.col(5) << n_I_6.cross(r_I_IE - r_I_I6);

    // std::cout << "Test, J_P:" << std::endl << J_P << std::endl;

    return J_P;
}

MatrixXd jointToRotJac(VectorXd q)
{
   // Input: vector of generalized coordinates (joint angles)
    // Output: J_R, Jacobian of the end-effector orientation which maps joint velocities to end-effector angular velocities in I frame.
    MatrixXd J_R(3,6);
    MatrixXd T_I0(4,4), T_01(4,4), T_12(4,4), T_23(4,4), T_34(4,4), T_45(4,4), T_56(4,4), T_6E(4,4);
    MatrixXd T_I1(4,4), T_I2(4,4), T_I3(4,4), T_I4(4,4), T_I5(4,4), T_I6(4,4);
    MatrixXd R_I1(3,3), R_I2(3,3), R_I3(3,3), R_I4(3,3), R_I5(3,3), R_I6(3,3);
    Vector3d n_1, n_2, n_3, n_4, n_5, n_6;

    //* Compute the relative homogeneous transformation matrices.
    T_I0 = getTransformI0();
    T_01 = jointToTransform01(q);
    T_12 = jointToTransform12(q);
    T_23 = jointToTransform23(q);
    T_34 = jointToTransform34(q);
    T_45 = jointToTransform45(q);
    T_56 = jointToTransform56(q);
    T_6E = getTransform6E();

    //* Compute the homogeneous transformation matrices from frame k to the inertial frame I.
    T_I1 = T_I0 * T_01;
    T_I2 = T_I0 * T_01 * T_12;
    T_I3 = T_I0 * T_01 * T_12 * T_23;
    T_I4 = T_I0 * T_01 * T_12 * T_23 * T_34;
    T_I5 = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45;
    T_I6 = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45 * T_56;

    //* Extract the rotation matrices from each homogeneous transformation matrix.
    R_I1 = T_I1.block(0,0,3,3);
    R_I2 = T_I2.block(0,0,3,3);
    R_I3 = T_I3.block(0,0,3,3);
    R_I4 = T_I4.block(0,0,3,3);
    R_I5 = T_I5.block(0,0,3,3);
    R_I6 = T_I6.block(0,0,3,3);

    //* Define the unit vectors around which each link rotate in the precedent coordinate frame.
    n_1 << 0,0,1;
    n_2 << 1,0,0;
    n_3 << 0,1,0;
    n_4 << 0,1,0;
    n_5 << 0,1,0;
    n_6 << 1,0,0;

    //* Compute the translational Jacobian.
    J_R.col(0) << R_I1 * n_1;
    J_R.col(1) << R_I2 * n_2;
    J_R.col(2) << R_I3 * n_3;
    J_R.col(3) << R_I4 * n_4;
    J_R.col(4) << R_I5 * n_5;
    J_R.col(5) << R_I6 * n_6;

    // std::cout << "Test, J_R:" << std::endl << J_R << std::endl;

    return J_R;
}

MatrixXd jointToRotJac_R(VectorXd q)
{
   // Input: vector of generalized coordinates (joint angles)
    // Output: J_R, Jacobian of the end-effector orientation which maps joint velocities to end-effector angular velocities in I frame.
    MatrixXd J_R(3,6);
    MatrixXd T_I0(4,4), T_01(4,4), T_12(4,4), T_23(4,4), T_34(4,4), T_45(4,4), T_56(4,4), T_6E(4,4);
    MatrixXd T_I1(4,4), T_I2(4,4), T_I3(4,4), T_I4(4,4), T_I5(4,4), T_I6(4,4);
    MatrixXd R_I1(3,3), R_I2(3,3), R_I3(3,3), R_I4(3,3), R_I5(3,3), R_I6(3,3);
    Vector3d n_1, n_2, n_3, n_4, n_5, n_6;

    //* Compute the relative homogeneous transformation matrices.
    T_I0 = getTransformI0();
    T_01 = jointToTransform01_R(q);
    T_12 = jointToTransform12(q);
    T_23 = jointToTransform23(q);
    T_34 = jointToTransform34(q);
    T_45 = jointToTransform45(q);
    T_56 = jointToTransform56(q);
    T_6E = getTransform6E();

    //* Compute the homogeneous transformation matrices from frame k to the inertial frame I.
    T_I1 = T_I0 * T_01;
    T_I2 = T_I0 * T_01 * T_12;
    T_I3 = T_I0 * T_01 * T_12 * T_23;
    T_I4 = T_I0 * T_01 * T_12 * T_23 * T_34;
    T_I5 = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45;
    T_I6 = T_I0 * T_01 * T_12 * T_23 * T_34 * T_45 * T_56;

    //* Extract the rotation matrices from each homogeneous transformation matrix.
    R_I1 = T_I1.block(0,0,3,3);
    R_I2 = T_I2.block(0,0,3,3);
    R_I3 = T_I3.block(0,0,3,3);
    R_I4 = T_I4.block(0,0,3,3);
    R_I5 = T_I5.block(0,0,3,3);
    R_I6 = T_I6.block(0,0,3,3);

    //* Define the unit vectors around which each link rotate in the precedent coordinate frame.
    n_1 << 0,0,1;
    n_2 << 1,0,0;
    n_3 << 0,1,0;
    n_4 << 0,1,0;
    n_5 << 0,1,0;
    n_6 << 1,0,0;

    //* Compute the translational Jacobian.
    J_R.col(0) << R_I1 * n_1;
    J_R.col(1) << R_I2 * n_2;
    J_R.col(2) << R_I3 * n_3;
    J_R.col(3) << R_I4 * n_4;
    J_R.col(4) << R_I5 * n_5;
    J_R.col(5) << R_I6 * n_6;

    // std::cout << "Test, J_R:" << std::endl << J_R << std::endl;

    return J_R;
}

MatrixXd pseudoInverseMat(MatrixXd A, double lambda) // 수도 역행렬. 정사각 행렬이 아닌 경우에.
{
    // Input: Any m-by-n matrix
    // Output: An n-by-m pseudo-inverse of the input according to the Moore-Penrose formula
    MatrixXd pinvA; //pseudo inverse A 
    
    int m = A.rows();
    int n = A.cols();

    if(m > n){ // left pseudo inverse matrix
        MatrixXd tmp_m = MatrixXd::Identity(n,n);
        pinvA = ( A.transpose() * A + lambda*lambda*tmp_m ).inverse() * A.transpose();
    }
    else if(m < n){ // right pseudo inverse matrix
        MatrixXd tmp_m = MatrixXd::Identity(m,m);
        pinvA = A.transpose() * (A * A.transpose() + lambda*lambda*tmp_m).inverse();
    }
    else{
        pinvA = A.inverse();
    }

    // std::cout << "pinvA : " << pinvA << std::endl;
    return pinvA;
}

VectorXd rotMatToRotVec(MatrixXd C)
{
    // Input: a rotation matrix C
    // Output: the rotational vector which describes the rotation C
    Vector3d phi,n;
    double th;
    
    // std::cout << "C(0,0) : " << C(0,0) << std::endl;
    th = acos((C(0,0) + C(1,1) + C(2,2) - 1) / 2.0);

    if(fabs(th)<0.001){
         n << 0,0,0;
    }
    else{
        n << (C(2,1) - C(1,2)), (C(0,2) - C(2,0)) , (C(1,0) - C(0,1)) ;
        n = (1.0 / (2.0*sin(th))) * n;
    }
        
    phi = th*n;
    
    // std::cout << "phi : " << phi << std::endl;
    return phi;
}

MatrixXd rotVecToRotMat(VectorXd C)
{
    VectorXd n(3);
    double nx, ny, nz, s, c, th;
    MatrixXd tmp_m(3,3);
    
    n = C/C.norm();
    th = C.norm();
    
    nx = n(0);
    ny = n(1);
    nz = n(2);
    s = sin(th);
    c = cos(th);
    
    tmp_m <<
        nx*nx*(1.0-c)+c,    nx*ny*(1.0-c)-nz*s, nx*nz*(1.0-c)+ny*s, \
        nx*ny*(1.0-c)+nz*s, ny*ny*(1.0-c)+c,    ny*nz*(1.0-c)-nx*s, \
        nx*nz*(1.0-c)-ny*s, ny*nz*(1.0-c)+nx*s, nz*nz*(1.0-c)+c;
                   
    return tmp_m;
}

VectorXd inverseKinematics(Vector3d r_des, MatrixXd C_des, VectorXd q0, double tol) 
{
    // Input: desired end-effector position, desired end-effector orientation, initial guess for joint angles, threshold for the stopping-criterion
    // Output: joint angles which match desired end-effector position and orientation
    //tolerance : 공차, dq : q의 미분값
    double num_it=0;
    MatrixXd J_P(3,6), J_R(3,6), J(6,6), pinvJ(6,6), C_err(3,3), C_IE(3,3);
    VectorXd q(6),dq(6),dXe(6);
    Vector3d dr, dph;
    double lambda;
    
    //* Set maximum number of iterations
    double max_it = 200;
    
    //* Initialize the solution with the initial guess

    q=q0;
    C_IE = jointToRotMat(q);
    C_err = C_des * C_IE.transpose();
    
    //* Damping factor
    lambda = 0.001;
    
    //* Initialize error
    dr = r_des - jointToPosition(q); 
    dph = rotMatToRotVec(C_err);
    dXe << dr(0), dr(1), dr(2), dph(0), dph(1), dph(2);
    
    ////////////////////////////////////////////////
    //** Iterative inverse kinematics
    ////////////////////////////////////////////////
    
    //* Iterate until terminating condition
    while (num_it<max_it && dXe.norm()>tol) // norm : 크기를 구하는 함수
    {
        
        //Compute Inverse Jacobian
        J_P = jointToPosJac(q);
        J_R = jointToRotJac(q);

        J.block(0,0,3,6) = J_P;
        J.block(3,0,3,6) = J_R; // Geometric Jacobian
        
        // Convert to Geometric Jacobian to Analytic Jacobian
        dq = pseudoInverseMat(J,lambda)*dXe;
        
        // Update law
        q += 0.5*dq;
        
        // Update error

        C_IE = jointToRotMat(q);
        C_err = C_des * C_IE.transpose();
        
        dr = r_des - jointToPosition(q);
        dph = rotMatToRotVec(C_err);
        dXe << dr(0), dr(1), dr(2), dph(0), dph(1), dph(2);
                   
        num_it++; 
    }
    std::cout << "iteration: " << num_it << ", value: " << q << std::endl;
    
    return q;
}

VectorXd inverseKinematics_R(Vector3d r_des, MatrixXd C_des, VectorXd q0, double tol) 
{
    // Input: desired end-effector position, desired end-effector orientation, initial guess for joint angles, threshold for the stopping-criterion
    // Output: joint angles which match desired end-effector position and orientation
    //tolerance : 공차, dq : q의 미분값
    double num_it=0;
    MatrixXd J_P(3,6), J_R(3,6), J(6,6), pinvJ(6,6), C_err(3,3), C_IE(3,3);
    VectorXd q(6),dq(6),dXe(6);
    Vector3d dr, dph;
    double lambda;
    
    //* Set maximum number of iterations
    double max_it = 200;
    
    //* Initialize the solution with the initial guess

    q=q0;
    C_IE = jointToRotMat_R(q);
    C_err = C_des * C_IE.transpose();
    
    //* Damping factor
    lambda = 0.001;
    
    //* Initialize error
    dr = r_des - jointToPosition_R(q); 
    dph = rotMatToRotVec(C_err);
    dXe << dr(0), dr(1), dr(2), dph(0), dph(1), dph(2);
    
    ////////////////////////////////////////////////
    //** Iterative inverse kinematics
    ////////////////////////////////////////////////
    
    //* Iterate until terminating condition
    while (num_it<max_it && dXe.norm()>tol) // norm : 크기를 구하는 함수
    {
        
        //Compute Inverse Jacobian
        J_P = jointToPosJac_R(q);
        J_R = jointToRotJac_R(q);

        J.block(0,0,3,6) = J_P;
        J.block(3,0,3,6) = J_R; // Geometric Jacobian
        
        // Convert to Geometric Jacobian to Analytic Jacobian
        dq = pseudoInverseMat(J,lambda)*dXe;
        
        // Update law
        q += 0.5*dq;
        
        // Update error

        C_IE = jointToRotMat_R(q);
        C_err = C_des * C_IE.transpose();
        
        dr = r_des - jointToPosition_R(q);
        dph = rotMatToRotVec(C_err);
        dXe << dr(0), dr(1), dr(2), dph(0), dph(1), dph(2);
                   
        num_it++; 
    }
    // std::cout << "iteration: " << num_it << ", value: " << q << std::endl;
    
    return q;
}

double func_1_cos(double t, double init, double final, double T)
{
        double des;
        
        des = init + ((final - init)/2) * (1-cos(PI*t/T));
        
        return des;
}

void practice(){
    std::cout << "practice function" << std::endl;

    // MatrixXd TI0(4,4), T01(4,4), T12(4,4), T23(4,4), T34(4,4), T45(4,4), T56(4,4), T6E(4,4); //동차변환행렬
    // MatrixXd TIE(4,4);
    // MatrixXd CIE(3,3); //회전행렬

    // VectorXd q(6); //generalized coordinates
    // q(0) = 10;
    // q(1) = 20;
    // q(2) = 30;
    // q(3) = 40;
    // q(4) = 50;
    // q(5) = 60;
    // q = q * D2R;

    // TI0 = getTransformI0();
    // T01 = jointToTransform01(q);
    // T12 = jointToTransform12(q);
    // T23 = jointToTransform23(q);
    // T34 = jointToTransform34(q);
    // T45 = jointToTransform45(q);
    // T56 = jointToTransform56(q);
    // T6E = getTransform6E();

    // TIE = TI0 * T01 * T12 * T23 * T34 * T45 * T56 * T6E;


    // CIE = jointToRotMat(q); //rotation matrix

    // MatrixXd J_P(3,6);
    // J_P = jointToPosJac(q);

    // MatrixXd J_R(3,6);
    // J_R = jointToRotJac(q); 

    // MatrixXd J(6,6);
    // J << jointToPosJac(q),\
    //      jointToRotJac(q);

    // MatrixXd pinvJ(6,6);
    // float lambda = 0.0;

    // pinvJ = pseudoInverseMat(J, lambda);
    // // std::cout << "pinvJ * J : " << pinvJ * J<< std::endl;


    // VectorXd q_des(6); // 목표
    // q_des = q;

    // VectorXd q_init(6); // 초기
    // q_init = 0.5 * q_des;

    // MatrixXd C_des(3,3);
    // C_des = jointToRotMat(q_des);

    // MatrixXd C_init(3,3);
    // C_init = jointToRotMat(q_init);

    // MatrixXd C_err(3,3);
    // C_err = C_des * C_init.transpose();

    // VectorXd dph(3); //d phi  피의 변화량
    // dph = rotMatToRotVec(C_err);
    // std::cout << "dph : " << dph << std::endl;

    // q << 0, 0, -60, 120, -60, 0; //pitch만 
    // q *= D2R;

    // r_des << 0, 0.105, -0.55;
    // r_des_R << 0, -0.105, -0.55;

    // C_des = MatrixXd::Identity(3,3); // 발바닥 자체는 회전하지 않으므로

    // q_cal = inverseKinematics(r_des, C_des, q*0.5, 0.001);
    // q_prev = q_cal;

    
    // q_cal_R = inverseKinematics_R(r_des_R, C_des, q*0.5, 0.001);
    // q_prev_R = q_cal_R;




    // C_init = MatrixXd::Identity(3,3);  
    

    


    // C_des2 << 0, -1, 0, \   
    //           1,  0, 0, \
    //           0,  0, 1;
    // // z축으로 90도 회전
    
    // C_err = C_des2 * C_init.transpose();
    // des_phi = rotMatToRotVec(C_err);



    // std::cout << "q_cal : " << q_cal << std::endl;
    // std::cout << "q_cal: " << q_cal * R2D<< std::endl;
}    

// q_cal:       0
//       0
// -63.756
// 127.512
// -63.756
//       0





void gazebo::rok3_plugin::Load(physics::ModelPtr _model, sdf::ElementPtr /*_sdf*/)
{
    
    /*
     * Loading model data and initializing the system before simulation 
     */

    std::cout << "Load function" << std::endl;
    
    //* model.sdf file based model data input to [physics::ModelPtr model] for gazebo simulation
    model = _model;

    //* [physics::ModelPtr model] based model update
    GetJoints();



    //* RBDL API Version Check
    int version_test;
    version_test = rbdl_get_api_version();
    printf(C_GREEN "RBDL API version = %d\n" C_RESET, version_test);

    //* model.urdf file based model data input to [Model* rok3_model] for using RBDL
    Model* rok3_model = new Model();
    // Addons::URDFReadFromFile("/home/ola/.gazebo/models/rok3_model/urdf/rok3_model.urdf", rok3_model, true, true);
    Addons::URDFReadFromFile("/home/ubuntu/.gazebo/models/rok3_model/urdf/rok3_model.urdf", rok3_model, true, true);
        // Addons::URDFReadFromFile("/root/.gazebo/models/rok3_model/urdf/rok3_model.urdf", rok3_model, true, true);
    //↑↑↑ Check File Path ↑↑↑
    nDoF = rok3_model->dof_count - 6; // Get degrees of freedom, except position and orientation of the robot
    joint = new ROBO_JOINT[nDoF]; // Generation joint variables struct

    //* initialize and setting for robot control in gazebo simulation
    initializeJoint();
    SetJointPIDgain();

    // 전부 0
    // q_init << 
    //         joint[LHY].actualRadian, \
    //         joint[LHR].actualRadian, \
    //         joint[LHP].actualRadian, \
    //         joint[LKN].actualRadian, \
    //         joint[LAP].actualRadian, \
    //         joint[LAR].actualRadian;
    
    // q_init_R << 
    //         joint[RHY].actualRadian, \
    //         joint[RHR].actualRadian, \
    //         joint[RHP].actualRadian, \
    //         joint[RKN].actualRadian, \
    //         joint[RAP].actualRadian, \
    //         joint[RAR].actualRadian;    

    // r_init << jointToPosition(q_init);
    // r_init_R << jointToPosition_R(q_init_R);

    // std::cout << "joint[LHP].actualRadian" << joint[LHP].actualRadian << std::endl;
    // std::cout << "joint[LKN].actualRadian" << joint[LKN].actualRadian << std::endl;
    // std::cout << "joint[LAP].actualRadian" << joint[LAP].actualRadian << std::endl;    


    //* setting for getting dt
    
    //last_update_time = model->GetWorld()->GetSimTime();
    #if GAZEBO_MAJOR_VERSION >= 8
        last_update_time = model->GetWorld()->SimTime();
    #else
        last_update_time = model->GetWorld()->GetSimTime();
    #endif

    update_connection = event::Events::ConnectWorldUpdateBegin(boost::bind(&rok3_plugin::UpdateAlgorithm, this));
    
    practice();

}

// thread
// 주기 1ms
void gazebo::rok3_plugin::UpdateAlgorithm()
{
    // std::cout << "update algorithm" << std::endl;
    /*
     * Algorithm update while simulation
     */

    //* UPDATE TIME : 1ms   // world에서 설정
    ///common::Time current_time = model->GetWorld()->GetSimTime();
    #if GAZEBO_MAJOR_VERSION >= 8
        common::Time current_time = model->GetWorld()->SimTime(); 
    #else
        common::Time current_time = model->GetWorld()->GetSimTime(); // get simulation time
    #endif

    dt = current_time.Double() - last_update_time.Double();  // dt가 1ms
    //    cout << "dt:" << dt << endl;
    time = time + dt;
    //    cout << "time:" << time << endl;

    //* setting for getting dt at next step
    last_update_time = current_time;


    //* Read Sensors data
    GetjointData();
    
    //* Target Angles

    // ctrl + R : 초기화. space : 시작, 정지
    // L_Foot_Sole의 pose값을 확인하면 약간 다름. 왜나면 가제보에는 중력이 영향. position, euler zyx를 x,y,z, yaw,pitch,roll과 동일시
    // joint[LHY].targetRadian = 10*D2R;
    // joint[LHR].targetRadian = 20*D2R;
    // joint[LHP].targetRadian = 30*D2R;
    // joint[LKN].targetRadian = 40*D2R;
    // joint[LAP].targetRadian = 50*D2R;
    // joint[LAR].targetRadian = 60*D2R;

    // 함수 실행 순서 : load -> practice -> update algorithm
    // q_init 는 load함수에서 acturalradian으로 현재 각도를 받아옴
    // q_cal 은 IK함수로 계산
    // T 는 5이다
    // ** sin 0 = sin 2pi = sin4pi ... 삼각함수는 주기성이 있다.

    //* Joint Space 
    if(time <= T){  //초기 자세 잡기


        C_des = MatrixXd::Identity(3,3);

        // q << 0, 0, -60, 120, -60, 0; //pitch만 
        q << 0, 0, -30, 60, -30, 0; 
        q *= D2R;
    
        r_des << 0, 0.105, -0.55;
        r_des_prev = r_des;

        r_des_R << 0, -0.105, -0.55;
        r_des_R_prev = r_des_R;
        // C_des = MatrixXd::Identity(3,3); // 발바닥 자체는 회전하지 않으므로  --  맨위에 선언함
        
    
        q_cal = inverseKinematics(r_des, C_des, q*0.5, 0.001); // q는 초기값이 아니라 추정값이다.
        q_prev = q_cal;
    
        
        q_cal_R = inverseKinematics_R(r_des_R, C_des, q*0.5, 0.001);
        q_prev_R = q_cal_R;

    
        joint[LHY].targetRadian = func_1_cos(time, 0, q_cal(0), T);
        joint[LHR].targetRadian = func_1_cos(time, 0, q_cal(1), T);
        joint[LHP].targetRadian = func_1_cos(time, 0, q_cal(2), T);
        joint[LKN].targetRadian = func_1_cos(time, 0, q_cal(3), T);
        joint[LAP].targetRadian = func_1_cos(time, 0, q_cal(4), T);
        joint[LAR].targetRadian = func_1_cos(time, 0, q_cal(5), T); 
        
        joint[RHY].targetRadian = func_1_cos(time, 0, q_cal_R(0), T);
        joint[RHR].targetRadian = func_1_cos(time, 0, q_cal_R(1), T);
        joint[RHP].targetRadian = func_1_cos(time, 0, q_cal_R(2), T);
        joint[RKN].targetRadian = func_1_cos(time, 0, q_cal_R(3), T);
        joint[RAP].targetRadian = func_1_cos(time, 0, q_cal_R(4), T);
        joint[RAR].targetRadian = func_1_cos(time, 0, q_cal_R(5), T); 

        cout << "joint[LHP].targetRadian" << joint[LAP].targetRadian << endl;
        cout << "joint[LKN].targetRadian" << joint[LKN].targetRadian << endl;
        cout << "joint[LAP].targetRadian" << joint[LAP].targetRadian << endl;

        cout << "joint[RHP].targetRadian" << joint[RAP].targetRadian << endl;
        cout << "joint[RKN].targetRadian" << joint[RKN].targetRadian << endl;
        cout << "joint[RAP].targetRadian" << joint[RAP].targetRadian << endl;


// joint[LHP].targetRadian-1.11275 // 63.76
// joint[LKN].targetRadian2.2255 //127.512
// joint[LAP].targetRadian-1.11275 // 63.76

    }

    // * Cartesian Space

    // else if (time > T && time < 2*T) { //왼발 y축으로 이동하기
    //     if(flag == 1){
    //         r_des << 0, 0.210, -0.55;
    //         r_des_R << 0, 0, -0.55;
    //         flag = 2;
    //     }
        


    //     r_x = func_1_cos(time-T, r_des_prev(0), r_des(0), T);
    //     r_y = func_1_cos(time-T, r_des_prev(1), r_des(1), T);
    //     r_z = func_1_cos(time-T, r_des_prev(2), r_des(2), T);

    //     r << r_x, r_y, r_z;
        
    //     // cout << "r :" << endl << r << endl;

    //     q = inverseKinematics(r, C_des, q_prev, 0.001);

    //     // cout << "q :" << endl << q*R2D << endl;
    //     q_prev = q;

    //     r_x_R = func_1_cos(time-T, r_des_R_prev(0), r_des_R(0), T);
    //     r_y_R = func_1_cos(time-T, r_des_R_prev(1), r_des_R(1), T);
    //     r_z_R = func_1_cos(time-T, r_des_R_prev(2), r_des_R(2), T);
            
    //     r_R << r_x_R, r_y_R, r_z_R;
               
    //     // cout << "r_R" << endl << r_R << endl;
    //     q_R = inverseKinematics_R(r_R, C_des, q_prev_R, 0.001);
    //     q_prev_R = q_R;        
        
    //     joint[LHY].targetRadian = q(0);
    //     joint[LHR].targetRadian = q(1);
    //     joint[LHP].targetRadian = q(2);
    //     joint[LKN].targetRadian = q(3);
    //     joint[LAP].targetRadian = q(4);
    //     joint[LAR].targetRadian = q(5);    
                
    //     joint[RHY].targetRadian = q_R(0);
    //     joint[RHR].targetRadian = q_R(1);
    //     joint[RHP].targetRadian = q_R(2);
    //     joint[RKN].targetRadian = q_R(3);
    //     joint[RAP].targetRadian = q_R(4);
    //     joint[RAR].targetRadian = q_R(5);          

    //     cout << "joint[LHP].targetRadian" << joint[LAP].targetRadian << endl;
    //     cout << "joint[LKN].targetRadian" << joint[LKN].targetRadian << endl;
    //     cout << "joint[LAP].targetRadian" << joint[LAP].targetRadian << endl;

    //     cout << "joint[RHP].targetRadian" << joint[RAP].targetRadian << endl;
    //     cout << "joint[RKN].targetRadian" << joint[RKN].targetRadian << endl;
    //     cout << "joint[RAP].targetRadian" << joint[RAP].targetRadian << endl;
    // }

    // else if (time >= 2*T && time < 3*T) { //왼발 위로 들기  왜안올라가냐?
        // if(flag == 2){
        //     r_des_prev = r;
        //     r_des_R_prev = r_R;

        //     r_des << 0, 0.210, -0.35;
        //     r_des_R << 0, 0, -0.55;
        //     flag = 3;
        // }
        


    //     // r_x = func_1_cos(time-2*T, r_des_prev(0), r_des(0), T);
    //     // r_y = func_1_cos(time-2*T, r_des_prev(1), r_des(1), T);
    //     // r_z = func_1_cos(time-2*T, r_des_prev(2), r_des(2), T);

    //     r_x = func_1_cos(time-2*T, 0, 0, T);
    //     r_y = func_1_cos(time-2*T, 0.210, 0.210, T);
    //     r_z = func_1_cos(time-2*T, -0.55, -0.35, T);
        
    //     // r_des_prev = r_des;

    //     r << r_x, r_y, r_z;
        
    //     cout << "r :" << endl << r << endl;
    //     cout << "C_des :" << endl << C_des << endl;
    //     cout << "q_prev : " << endl << q_prev*R2D << endl;

    //     q = inverseKinematics(r, C_des, q_prev, 0.001);

    //     cout << "q :" << endl << q*R2D << endl;
    //     q_prev = q;
        

        
    //     // r_des_R_prev = r_des_R;

    //     // r_x_R = func_1_cos(time-2*T, r_des_R_prev(0), r_des_R(0), T);
    //     // r_y_R = func_1_cos(time-2*T, r_des_R_prev(1), r_des_R(1), T);
    //     // r_z_R = func_1_cos(time-2*T, r_des_R_prev(2), r_des_R(2), T);

    //     r_x_R = func_1_cos(time-2*T, 0, 0, T);
    //     r_y_R = func_1_cos(time-2*T, 0, 0, T);
    //     r_z_R = func_1_cos(time-2*T, -0.55, -0.55, T);
            
    //     r_R << r_x_R, r_y_R, r_z_R;
               
    //     // cout << "r_R" << endl << r_R << endl;
    //     q_R = inverseKinematics_R(r_R, C_des, q_prev_R, 0.001);
    //     q_prev_R = q_R;        
        
    //     joint[LHY].targetRadian = q(0);
    //     joint[LHR].targetRadian = q(1);
    //     joint[LHP].targetRadian = q(2);
    //     joint[LKN].targetRadian = q(3);
    //     joint[LAP].targetRadian = q(4);
    //     joint[LAR].targetRadian = q(5);    
                
    //     joint[RHY].targetRadian = q_R(0);
    //     joint[RHR].targetRadian = q_R(1);
    //     joint[RHP].targetRadian = q_R(2);
    //     joint[RKN].targetRadian = q_R(3);
    //     joint[RAP].targetRadian = q_R(4);
    //     joint[RAR].targetRadian = q_R(5);          
    // }

    // else if(time > 2*T && time <= 3*T){
    //     r_x = func_1_cos(time - 2*T, 0, 0.5, T);   //시간 정확히 기입하기
    //     r_y = func_1_cos(time - 2*T, 0.210, 0.210, T);
    //     r_z = func_1_cos(time - 2*T, -0.55, -0.55, T);

    //     r << r_x, r_y, r_z;
        
    //     cout << "r :" << endl << r << endl;

    //     q = inverseKinematics(r, C_des, q_prev, 0.001);
    //     q_prev = q;

    //     cout << "q :" << endl << q*R2D << endl;

    //     r_x_R = func_1_cos(time - 2*T, 0, 0, T);
    //     r_y_R = func_1_cos(time - 2*T, 0, 0, T);
    //     r_z_R = func_1_cos(time - 2*T, -0.55, -0.55, T);
            
    //     r_R << r_x_R, r_y_R, r_z_R;
               
    //     // cout << "r_R" << endl << r_R << endl;
    //     q_R = inverseKinematics_R(r_R, C_des, q_prev_R, 0.001);
    //     q_prev_R = q_R;        

    //     joint[LHY].targetRadian = q(0);
    //     joint[LHR].targetRadian = q(1);
    //     joint[LHP].targetRadian = q(2);
    //     joint[LKN].targetRadian = q(3);
    //     joint[LAP].targetRadian = q(4);
    //     joint[LAR].targetRadian = q(5);  

    //     joint[RHY].targetRadian = q_R(0);
    //     joint[RHR].targetRadian = q_R(1);
    //     joint[RHP].targetRadian = q_R(2);
    //     joint[RKN].targetRadian = q_R(3);
    //     joint[RAP].targetRadian = q_R(4);
    //     joint[RAR].targetRadian = q_R(5);  
    // }

    // else if(time > 2*T && time < 3*T){
    //     r_x = func_1_cos(time - 2*T, 0, 0, T);
    //     r_y = func_1_cos(time - 2*T, 0.105, 0.105, T);
    //     r_z = func_1_cos(time - 2*T, -0.35, -0.55, T);

    //     r << r_x, r_y, r_z;

    //     q = inverseKinematics(r, C_des, q_prev, 0.001);
    //     q_prev = q;

    //    joint[LHY].targetRadian = q(0);
    //    joint[LHR].targetRadian = q(1);
    //    joint[LHP].targetRadian = q(2);
    //    joint[LKN].targetRadian = q(3);
    //    joint[LAP].targetRadian = q(4);
    //    joint[LAR].targetRadian = q(5);  
    //     // std::cout << "joint[LHP].targetRadian" << joint[LHP].targetRadian << std::endl;
    //     // std::cout << "joint[LKN].targetRadian" << joint[LKN].targetRadian << std::endl;
    //     // std::cout << "joint[LAP].targetRadian" << joint[LAP].targetRadian << std::endl;
    // }
    // else if(time >= 3*T && time < 4*T)
    // {
    //     phi_x = func_1_cos(time - 3*T, 0, des_phi(0), T);
    //     phi_y = func_1_cos(time - 3*T, 0, des_phi(1), T);
    //     phi_z = func_1_cos(time - 3*T, 0, des_phi(2), T);

    //     phi << phi_x, phi_y, phi_z;

    //     C_tmp = rotVecToRotMat(phi);
    //     std::cout << "C_tmp : " << endl << C_tmp << std::endl;
    //     r2 << 0, 0.105, -0.55; //발바닥 중심이 이 위치에서 고정되어있어야 하고 z방향으로 돌기만 해야한다.

    //     q = inverseKinematics(r2, C_tmp, q_prev, 0.001);
    //     q_prev = q;
    //    joint[LHY].targetRadian = q(0);
    //    joint[LHR].targetRadian = q(1);
    //    joint[LHP].targetRadian = q(2);
    //    joint[LKN].targetRadian = q(3);
    //    joint[LAP].targetRadian = q(4);
    //    joint[LAR].targetRadian = q(5);   
    // }
  /*First motion Complete.*/

/*
과제 7

1. base를 fix 풀기

model.sdf 에서 
  <joint name="fixed to world" type="fixed">
      <parent>world</parent>
      <child>base_link</child>
    </joint>

    없애기

2. base의 위치를 조정하기
rok3.world에서 
   <pose frame=''>0 0 1.947 0 0 0</pose> 에서
   1.947을 0.947로 바꾸기
   이유 : base가 0.947정도로 되니까 발바닥이 땅정도에 위치한다.
*/

    //* Joint Controller
    jointController();
}

void gazebo::rok3_plugin::jointController()
{
    /*
     * Joint Controller for each joint
     */

    // Update target torque by control
    for (int j = 0; j < nDoF; j++) {
        joint[j].targetTorque = joint[j].Kp * (joint[j].targetRadian-joint[j].actualRadian)\
                              + joint[j].Kd * (joint[j].targetVelocity-joint[j].actualVelocity);
    }

    // Update target torque in gazebo simulation     
    L_Hip_yaw_joint->SetForce(0, joint[LHY].targetTorque);
    L_Hip_roll_joint->SetForce(0, joint[LHR].targetTorque);
    L_Hip_pitch_joint->SetForce(0, joint[LHP].targetTorque);
    L_Knee_joint->SetForce(0, joint[LKN].targetTorque);
    L_Ankle_pitch_joint->SetForce(0, joint[LAP].targetTorque);
    L_Ankle_roll_joint->SetForce(0, joint[LAR].targetTorque);

    R_Hip_yaw_joint->SetForce(0, joint[RHY].targetTorque);
    R_Hip_roll_joint->SetForce(0, joint[RHR].targetTorque);
    R_Hip_pitch_joint->SetForce(0, joint[RHP].targetTorque);
    R_Knee_joint->SetForce(0, joint[RKN].targetTorque);
    R_Ankle_pitch_joint->SetForce(0, joint[RAP].targetTorque);
    R_Ankle_roll_joint->SetForce(0, joint[RAR].targetTorque);

    torso_joint->SetForce(0, joint[WST].targetTorque);
}

void gazebo::rok3_plugin::GetJoints()
{
    /*
     * Get each joints data from [physics::ModelPtr _model]
     */

    //* Joint specified in model.sdf
    L_Hip_yaw_joint = this->model->GetJoint("L_Hip_yaw_joint");
    L_Hip_roll_joint = this->model->GetJoint("L_Hip_roll_joint");
    L_Hip_pitch_joint = this->model->GetJoint("L_Hip_pitch_joint");
    L_Knee_joint = this->model->GetJoint("L_Knee_joint");
    L_Ankle_pitch_joint = this->model->GetJoint("L_Ankle_pitch_joint");
    L_Ankle_roll_joint = this->model->GetJoint("L_Ankle_roll_joint");
    R_Hip_yaw_joint = this->model->GetJoint("R_Hip_yaw_joint");
    R_Hip_roll_joint = this->model->GetJoint("R_Hip_roll_joint");
    R_Hip_pitch_joint = this->model->GetJoint("R_Hip_pitch_joint");
    R_Knee_joint = this->model->GetJoint("R_Knee_joint");
    R_Ankle_pitch_joint = this->model->GetJoint("R_Ankle_pitch_joint");
    R_Ankle_roll_joint = this->model->GetJoint("R_Ankle_roll_joint");
    torso_joint = this->model->GetJoint("torso_joint");

    //* FTsensor joint
    LS = this->model->GetJoint("LS");
    RS = this->model->GetJoint("RS");
}

void gazebo::rok3_plugin::GetjointData()
{
    /*
     * Get encoder and velocity data of each joint
     * encoder unit : [rad] and unit conversion to [deg]
     * velocity unit : [rad/s] and unit conversion to [rpm]
     */
    
  #if GAZEBO_MAJOR_VERSION >= 8

    
    joint[LHY].actualRadian = L_Hip_yaw_joint->Position(0);
    joint[LHR].actualRadian = L_Hip_roll_joint->Position(0);
    joint[LHP].actualRadian = L_Hip_pitch_joint->Position(0);
    joint[LKN].actualRadian = L_Knee_joint->Position(0);
    joint[LAP].actualRadian = L_Ankle_pitch_joint->Position(0);
    joint[LAR].actualRadian = L_Ankle_roll_joint->Position(0);

    joint[RHY].actualRadian = R_Hip_yaw_joint->Position(0);
    joint[RHR].actualRadian = R_Hip_roll_joint->Position(0);
    joint[RHP].actualRadian = R_Hip_pitch_joint->Position(0);
    joint[RKN].actualRadian = R_Knee_joint->Position(0);
    joint[RAP].actualRadian = R_Ankle_pitch_joint->Position(0);
    joint[RAR].actualRadian = R_Ankle_roll_joint->Position(0);

    joint[WST].actualRadian = torso_joint->Position(0);
    
  #else
    joint[LHY].actualRadian = L_Hip_yaw_joint->GetAngle(0).Radian();
    joint[LHR].actualRadian = L_Hip_roll_joint->GetAngle(0).Radian();
    joint[LHP].actualRadian = L_Hip_pitch_joint->GetAngle(0).Radian();
    joint[LKN].actualRadian = L_Knee_joint->GetAngle(0).Radian();
    joint[LAP].actualRadian = L_Ankle_pitch_joint->GetAngle(0).Radian();
    joint[LAR].actualRadian = L_Ankle_roll_joint->GetAngle(0).Radian();

    joint[RHY].actualRadian = R_Hip_yaw_joint->GetAngle(0).Radian();
    joint[RHR].actualRadian = R_Hip_roll_joint->GetAngle(0).Radian();
    joint[RHP].actualRadian = R_Hip_pitch_joint->GetAngle(0).Radian();
    joint[RKN].actualRadian = R_Knee_joint->GetAngle(0).Radian();
    joint[RAP].actualRadian = R_Ankle_pitch_joint->GetAngle(0).Radian();
    joint[RAR].actualRadian = R_Ankle_roll_joint->GetAngle(0).Radian();

    joint[WST].actualRadian = torso_joint->GetAngle(0).Radian();
  #endif


    for (int j = 0; j < nDoF; j++) {
        joint[j].actualDegree = joint[j].actualRadian*R2D;
    }


    joint[LHY].actualVelocity = L_Hip_yaw_joint->GetVelocity(0);
    joint[LHR].actualVelocity = L_Hip_roll_joint->GetVelocity(0);
    joint[LHP].actualVelocity = L_Hip_pitch_joint->GetVelocity(0);
    joint[LKN].actualVelocity = L_Knee_joint->GetVelocity(0);
    joint[LAP].actualVelocity = L_Ankle_pitch_joint->GetVelocity(0);
    joint[LAR].actualVelocity = L_Ankle_roll_joint->GetVelocity(0);

    joint[RHY].actualVelocity = R_Hip_yaw_joint->GetVelocity(0);
    joint[RHR].actualVelocity = R_Hip_roll_joint->GetVelocity(0);
    joint[RHP].actualVelocity = R_Hip_pitch_joint->GetVelocity(0);
    joint[RKN].actualVelocity = R_Knee_joint->GetVelocity(0);
    joint[RAP].actualVelocity = R_Ankle_pitch_joint->GetVelocity(0);
    joint[RAR].actualVelocity = R_Ankle_roll_joint->GetVelocity(0);

    joint[WST].actualVelocity = torso_joint->GetVelocity(0);


    //    for (int j = 0; j < nDoF; j++) {
    //        cout << "joint[" << j <<"]="<<joint[j].actualDegree<< endl;
    //    }

}

void gazebo::rok3_plugin::initializeJoint()
{
    /*
     * Initialize joint variables for joint control
     */
    
    for (int j = 0; j < nDoF; j++) {
        joint[j].targetDegree = 0;
        joint[j].targetRadian = 0;
        joint[j].targetVelocity = 0;
        joint[j].targetTorque = 0;
        
        joint[j].actualDegree = 0;
        joint[j].actualRadian = 0;
        joint[j].actualVelocity = 0;
        joint[j].actualRPM = 0;
        joint[j].actualTorque = 0;
    }
}

void gazebo::rok3_plugin::SetJointPIDgain()
{
    /*
     * Set each joint PID gain for joint control
     */
    joint[LHY].Kp = 2000;
    joint[LHR].Kp = 9000;
    joint[LHP].Kp = 2000;
    joint[LKN].Kp = 5000;
    joint[LAP].Kp = 3000;
    joint[LAR].Kp = 3000;

    joint[RHY].Kp = joint[LHY].Kp;
    joint[RHR].Kp = joint[LHR].Kp;
    joint[RHP].Kp = joint[LHP].Kp;
    joint[RKN].Kp = joint[LKN].Kp;
    joint[RAP].Kp = joint[LAP].Kp;
    joint[RAR].Kp = joint[LAR].Kp;

    joint[WST].Kp = 2.;

    joint[LHY].Kd = 2.;
    joint[LHR].Kd = 2.;
    joint[LHP].Kd = 2.;
    joint[LKN].Kd = 4.;
    joint[LAP].Kd = 2.;
    joint[LAR].Kd = 2.;

    joint[RHY].Kd = joint[LHY].Kd;
    joint[RHR].Kd = joint[LHR].Kd;
    joint[RHP].Kd = joint[LHP].Kd;
    joint[RKN].Kd = joint[LKN].Kd;
    joint[RAP].Kd = joint[LAP].Kd;
    joint[RAR].Kd = joint[LAR].Kd;

    joint[WST].Kd = 2.;
}


